\chapter{Analyse}

Das Folgende Kapitel beschreibt den Analyse Algorithmus, des von mir entworfenen Systems.
Im ersten Abschnitt sollen die verwendeten Datenstrukturen vorgestellt und beschrieben werden.
Der zweite Abschnitt beschreibt den eigentlichen Algorithmus.

\section{Datenstrukturen}

Für den Algorithmus wurden zwei grundlegende Datenstrukturen entworfen. Der 
\textit{Datenflussgraph} repräsentiert den Datenfluss der Referenzen innerhalb 
einer Methode und wird im ersten Abschnitt vorgestellt. Zu optimierende Referenzen
werden in diesem Graphen mit sogenannten \textit{Labels} versehen. Dieser Datentyp
soll im zweiten Abschnitt beschrieben werden.

\subsection{Datenfluss Graph}

Eine auf einem IR basierende Methode wird vom System mittels eines Datenflussgraphen 
repräsentiert. Dieser wird vor der eigentlichen Analyse aus einer gegeben
Methode und einer Menge an initialen Referenzen vom \texttt{DataFlowGraphBuilder}
erzeugt. Der Graph ist gerichtet und setzt sich aus zwei verschiedenen Knoten zusammen:

\begin{itemize}
	\item \texttt{Reference}: eine value number aus dem IR
	\item \texttt{InstructionNode}: eine Instruktion aus dem IR
\end{itemize}

Sei im Folgenden der Datenflussgraph $G = (V, E)$, $R$ die Menge aller \texttt{Reference} 
Knoten und $I$ die Menge aller \texttt{InstructionNode}s. 
\\
Im Graph gilt $\forall (x, y) \in V,  (x \in R \wedge y \in I) \vee (x \in I \wedge y \in X)$.
Eine Kante $i \in I, r \in R, (i, r)$ beschreibt eine \textit{Definition}, die aussagt, 
dass die Referenz $r$ durch die Instruktion $i$ definiert wird. Ein Kante 
$i \in I, r \in R, (r, i)$ ist eine \textit{Benutzung} (im folgenden \textit{Use}
genannt). 

\texttt{Reference} Knoten werden für jede betroffene value number erzeugt. Für
die Erstellung von \texttt{InstructionNode} Objekten steht die 
\texttt{InstructionNodeFactory} zur Verfügung, die für eine gegebene 
\texttt{SSAInstruction} eine entsprechende \texttt{InstructionNode} erstellt. Um
für dieselbe \texttt{SSAInstruction} immer dasselbe \texttt{InstructionNode} 
Objekt zu garantieren verwendet die Factory einen internen Cache, der eine 
Abbildung $SSAInstruction \rightarrow InstructionNode$ verwaltet und für jede 
\texttt{SSAInstruction} prüft ob für diese bereits eine \texttt{InstructionNode} 
erstellt wurde.

Die Erstellung eines \texttt{DataFlowGraph}s beginnt immer mit einer Menge an 
initialen \texttt{Reference} Objekten. Ausgehend von dieser Startmenge werden über 
das \texttt{DefUse}-Objekt des betroffenen IRs die Definition und alle Uses in den 
Datenflussgraphen eingefügt. Algorithmus \ref{alg:dfg} beschreibt die Erstellung des 
Graphen.

\begin{algorithm}[H]
	\caption{Erstellung des Datenflussgraphen}\label{alg:dfg}
	\begin{algorithmic}[1]
		\STATE $q \gets$ \texttt{new Queue($initialReferences$)}
		\STATE $g \gets$ \texttt{new DataFlowGraph()}
		\WHILE {\texttt{not $q$.isEmpty()}}
			\STATE $r \gets q$\texttt{.remove()}
			\IF {\texttt{not $g$.contains()}}

				\STATE $def \gets$ \texttt{$defUse$.getDef($r$)}
				\STATE $uses \gets$ \texttt{$defUse$.getUses($r$)}

				\STATE \texttt{$newInd$.add($def$)}
				\STATE \texttt{$newInd$.add($uses$)}

				\STATE \texttt{$r$.setDef(factory.create($def$))}

				\FOR{\texttt{$ins \in defUse$.getUses($r$)}}
					\STATE \texttt{$r$.addUse(factory.create($ins$))}
				\ENDFOR
				\FOR{$ins \in newIns$}
					\STATE \texttt{$q$.add($ins$.getConnectedRefs())}
				\ENDFOR
				\STATE \texttt{$g$.add($r$))}
			\ENDIF
		\ENDWHILE
		\RETURN $g$
	\end{algorithmic}
\end{algorithm}

Jede \texttt{InstructionNode} besitzt eine Definition, die Nummer der Referenz 
die diese Instruktion erzeugt und eine Liste von Uses, die Nummern der Referenzen 
die es benutzt. Darüber hinaus noch Informationen zu Bytecode Spezifika, die 
im Kapitel \ref{sec:locals} betrachtet werden.

Für verschiedene \texttt{SSAInstruction} Typen existieren entsprechende 
\texttt{InstructionNode} Subtypen. Allerdings gibt es auch Typen die nicht
einer \texttt{SSAInstruction} zugeordnet werden können. Im Folgenden sollen die
wichtigsten Knotentypen vorgestellt werden. Es existieren darüber hinaus weitere
für die das System zur Zeit keine Unterstützung bietet, da es ausschließlich für 
String Typen und komplexe Objekte ausgelegt ist.

\subsubsection{MethodCallNode}

Eine \texttt{MethodCallNode} repräsentiert einen Methoden Aufruf. Es besitzt, wenn
vorhanden, eine Definition, welche den Rückgabewert repräsentiert, einen Receiver, 
wenn es keine statische Methode ist und eine Liste an Parametern. Zusätzlich die 
aufgerufene Methode. 

\subsubsection{ContantNode}

Dieser Knoten Typ stellt eine Konstanten Definition dar. Er besitzt ausschließlich 
die Definition, welcher Referenz diese Konstante zugewiesen wird. Für diesen Typ
existiert keine entsprechende \texttt{SSAInstruction}.

\subsubsection{ParameterNode}

Die \texttt{ParameterNode} stellt eine Definition eines Parameters der Methode dar.
Wird eine Variable innerhalb der Methode als Parameter in der Methoden Signatur
deklariert, wird deren Definition als \texttt{ParameterNode} im Datenflussgraphen
repräsentiert. Für diesen Typ existiert keine entsprechende \texttt{SSAInstruction}.

\subsubsection{NewNode}

Dieser Typ entspricht einer \texttt{NEW} Anweisung, die ein neues Objekt eines 
gegebenen Typen erstellt. Es besitzt eine Definition und den Typ des instanziierten
Objekts. 

\subsubsection{ReturnNode}

\texttt{ReturnNode} Typen sind \texttt{RETURN} Anweisungen. Die besitzen 
ausschließlich eine Referenz als Use. Diejenige Referenz, die sie aus der Methode 
zurückgeben. Dieser Typ kann keine Definition darstellen.

\subsubsection{PhiNode}

Die \texttt{PhiNode} steht für eine $\phi$-Instruktion aus dem IR. Sie besitzt eine
Referenz als Definition und 2 bis $n$ Uses.

\subsection{Label}

Das \textit{Label} entspricht einer Markierung, mit der Knoten in einem 
Datenflussgraphen versehen werden können. Dabei steht ein Label (oder 
\texttt{TypeLabel}, wie der Datentyp im System heißt) für einen Optimierten Typ.
Die Semantik hinter einem markierten Knoten ist, dass diese Referenz bzw. Instruktion
durch den entsprechenden Optimierten Typ ersetzt werden kann.

Es kann nicht für alle \texttt{InstructionNode}s ein Label gesetzt werden. Genauer
gesagt lassen sich ausschließlich für die Knotentypen \texttt{MethodCallNode}, 
\texttt{NewNode} und \texttt{PhiNode} ein Label setzen, da sich nur diese 
Instruktionen in einen optimierten Typ umwandeln lassen.

Das \texttt{TypeLabel} beinhaltet alle Regeln, die für die Verwendung eines
Optimierten Typen existieren. Dazu gehören

\begin{itemize}
	\item der Originale, sowie der Optimierte Typ
	\item die Methoden für die Optimierungen im optimierten Typ angeboten werden
	\item alle Methoden die darüber hinaus vom Optimierten Typ unterstützt werden
	\item Methoden, die den optimierten Typ als Rückgabewert zurückgeben
	\item kompatible Label
\end{itemize}

Dabei ist diese Liste bereits eine Abstraktion zu den Methoden, die das Interface 
besitzt. Im System lassen sich Label Definition auf 2 Arten erstellen:

\begin{enumerate} 
	\item Durch das Implementieren des Interfaces \texttt{TypeLabel}
	\item Durch das Erstellen einer \texttt{.type} Datei
\end{enumerate}

Zwar unterstützt das Kommandozeilen Tool zur Zeit nur die zweite Variante,
programmatisch lässt sich allerdings auch die erste Alternative umsetzen. Im 
Folgenden sollen die beiden Möglichkeiten zur Definition eines \texttt{TypeLabel}s
betrachtet werden.

\subsubsection{Das TypeLabel Interface}

Das Interface beinhaltet alle Methoden, die der Analyse- und Transformationsprozess
benötigt. In diesem Kapitel sollen zunächst nur die Methode betrachtet werden, die
für den Analyse Algorithmus verwendet werden, die Übrigen werden im Abschnitt 
\ref{ssec:infoLabel} betrachtet. 

\begin{description}
	\item[\texttt{canBeUsedAsReceiverFor(MethodReference)}] Legt fest, ob eine 
	markierte Referenz als Empfänger für den übergebenen Methodenaufruf dienen kann.
	\item[\texttt{canBeUsedAsParamFor(MethodReference,int)}] Bestimmt, ob eine 
	markierte Referenz als Parameter in dem gegebenen Methodenaufruf an der 
	entsprechenden Stelle (der \texttt{int} Parameter) verwendet werden kann.
	\item[\texttt{canBeDefinedAsResultOf(MethodReference)}] Sagt aus, ob die 
	gegebene Methode einen optimierten Typ zurückgeben kann. Dies impliziert, dass
	der Methodenaufruf selber auch markiert ist.
	\item[\texttt{findTypeUses(AnalyzedMethod)}] Gibt eine Menge an \texttt{Reference}
	Objekten zurück, auf denen innerhalb der gegebenen Methode eine der von 
	der Optimierung betroffenen Methode aufgerufen wird. Für diesen Algorithmus 
	existiert bereits eine Implementierung in der Klasse \texttt{BaseTypeLabel}.
	\item[\texttt{compatibleWith(TypeLabel)}] Gibt an, ob das übergebene Label 
	kompatibel mit diesem Label ist.
\end{description}

Alle diese Methoden werden von den \texttt{InstructionNode} Implementierungen 
verwendet. Wie genau das passiert wird im Abschnitt \textit{Algorithmus} beschrieben.

\subsubsection{Das .type Dateiformat}

Da das Implementieren des Interfaces eher komplex ist, wurde für die einfachere 
Definition eines Types ein Datei Format entwickelt, welches von der Komplexität des
Interfaces abstrahieren soll. In dieser werden nicht die Regeln selbst, sondern 
die Fakten beschrieben, aus denen die Regeln für den Algorithmus hergeleitet werden 
können, beschrieben.

Aus einer Datei im \texttt{type} Format wird mittels eines internen Parsers ein
\texttt{TypeLabelConfig} Objekt erzeugt, welches als \texttt{TypeLabel} Objekt für
den Algorithmus fungiert.

Für die inhaltliche Struktur der Datei wurde JSON (JavaScript Object Notation) 
gewählt eine Darstellung anzubieten, die sowohl für Menschen als auch für das 
Programm leicht zu lesen und zu verstehen ist. Die Attribute innerhalb der Datei 
werden im Folgenden beschrieben:

\begin{description}
	\item[name] Der Name des Labels
	\item[originalType] Der voll qualifizierte Name des zu ersetzenden Typs
	\item[optimizedType] Der voll qualifizierte Name des zu optimierten Typs
	\item[methodDefs] Liste von Methoden, diesen wird eine ID vergeben um sie im 
	folgenden über diese ID zu referenzieren. Ein Eintrag in dieser Liste setzt
	sich zusammen aus:
	\begin{description}
		\item[id] eine eindeutige ID für die diese Methode
		\item[desc] die Beschreibung dieser Methode. Dies ist ein eigenes Objekt 
		und besteht aus den Attributen:
		\begin{description}
			\item[name] der Name der Methode
			\item[signature] der Signatur der Methode. Zusammengesetzt aus der
			Parameterliste und der Rückgabewert. Die Typen müssen dabei in der 
			internen JVM Form angegeben werden. (Beispiel: "\texttt{(I)Ljava/lang/String;}"
			, ein Parameter vom Typ \texttt{int} und Rückgabewert vom Typ
			\texttt{java.lang.String})
		\end{description}	
	\end{description}
	\item[effectedMethods] Liste von Methoden IDs. Für diese Methoden existieren 
	optimierte Varianten in dem optimierten Typen.
	\item[supportedMethods] Liste von Methoden IDs. Diese Methoden werden auch vom
	optimierten Typ unterstützt. Es handelt sich bei diesen aber nicht um Optimierungen.
	\item[producingMethods] Liste von Methoden IDs. Alle diesen Methoden erzeugen 
	in ihrer optimierten Variante optimierte Typen.
	\item[compatibleLabel] Liste von Strings. Alle Labels die mit diesem Label
	kompatibel sind.
	\item[parameterUsage] Ein Objekt. Dabei ist jeder key die ID einer Methode 
	und der entsprechende value eine Liste von Ganzzahlen. Ein Eintrag bedeutet, 
	dass diese Methode mit einem Optimierten Typ als Parameter mit diesem Index 
	umgehen kann. 
	\item[staticFactory] Ein String. Der Name einer statischen Factory Methode mit 
	einem Übergabeparameter vom Typ des Originalen Typs. Diese muss einen entsprechenden
	Optimierten Typ zurückgeben.
	\item[toOriginalType] Ein String, Der Name einer Methode ohne Parameter, die
	aus dem optimierten Objekt, ein entsprechendes vom Originalen Typ zurückgibt.

\end{description}

\section{Algorithmus}

In diesem Abschnitt soll die Idee hinter dem Analyse Algorithmus sowie dessen
Implementierung vorgestellt werden. Hierzu wird zunächst das Konzept der "Bubble"
erläutert um danach die Umsetzung dieses Konzepts im eigentlich Algorithmus zu 
betrachten.

\subsection{Motivation}

Optimierte Referenzen sind im Falle von String Objekten nicht kompatibel mit den 
Originalen. So treten Probleme in den Folgenden Szenarien auf:

\begin{description}
	\item[Referenz als Methoden Parameter] Die Signatur der 
	optimierten Methode, wird nicht verändert, da es dazu führen würde, dass
	Klienten Code, der diese Methode weiterhin mit dem originalen Typ aufruft, 
	nicht mehr kompilieren würde.
	\item[Referenz als Rückgabewert] Ein ähnliches Problem existiert, wenn die 
	Referenz zurückgegeben wird. Die Signatur der Methode definiert den Originalen
	Typ als Rückgabetyp und das zurückgeben eines anderen Typs als eben dieser 
	definierte würde zu Laufzeitfehlern führen.
	\item[Methodenaufruf auf Referenz] Wird diese optimierte Referenz als Empfänger 
	von einer Methode verwendet, die nicht zu den optimierten oder unterstützen
	Methoden dieses optimierten Typs gehört, würde es zu Laufzeitfehlern kommen, 
	da diese aufzurufende Methode nicht im optimierten Typ vorhanden ist. 
	\item[Feld Zugriff (\texttt{GETFIELD}, \texttt{PUTFIELD})] Wird die optimierte 
	Referenz in ein oder aus einem Feld innerhalb eines Objektes (oder in ein 
	statisches Feld einer Klasse) gesetzt, stimmt auch in diesem Szenario der Typ
	des optimierten und des originalen Objekts nicht überein.
	\item[Array Zugriff] Bei dem Zugriff auf ein Array, sowohl lesend als auch 
	schreibend, existiert eine Unstimmigkeit mit dem Typ des Arrays.
	\item[Referenz Aufruf Parameter] Wird die Referenz als Parameter für einen
	Methoden Aufruf verwendet und diese Methode ist nicht in der Label Definition
	als Methode deklariert, die mit einem optimierten Typ umgehen kann, dann 
	erwartet diese Methode den originalen Typ und nicht den optimierten.
\end{description}

Erweitert allerdings der optimierte Typ seinen originalen Typ so wäre, durch den 
Polymorphismus, der optimierte Typ genauso wie der originale verwendbar. Allerdings 
ist der Typ \texttt{java.lang.String} final, was bedeutet, dass von diesem Typ nicht 
abgeleitet werden kann. Darüber hinaus bieten sich Ableitungen für Optimierungen nicht
an, da das dynamische dispatchen zusätzlichen Aufwand für die JVM darstellt, da 
zunächst die Implementierung des Methode zu lokalisieren.

Aus diesem Grund müssen in den Code Konvertierungen in und vom optimierten Typ 
eingefügt werden. Eine Konvertierung zum optimierten Typ muss vor dem zu optimierenden
Methodenaufruf erfolgen. Eine Umwandlung vom optimierten Typ allerdings muss vor einer 
nicht kompatiblen Benutzung dieser Referenz erfolgen um bei dieser den originalen Typ 
zu verwenden.

\subsection{Die "Bubble"}

Da Konvertierungen zusätzliche Laufzeit erfordern, muss es das Ziel sein die Anzahl 
der durchgeführten Konvertierungen zu minimieren. Dies wird erreicht indem man den
Bereich, in dem ein optimierter Typ statt des originalen innerhalb der Methode 
verwendet maximiert. Dieser Bereich, in dem ein optimierter, statt des originalen, 
Typs für eine Referenz verwendet wird, wird im Folgenden \textit{Bubble} genannt. 

Die Bubble entsteht mittels der Markierung von Knoten im Datenflussgraphen. Es wird 
für jede gegebene Instanz vom Typ \texttt{TypeLabel} eine Bubble auf dem Graphen 
erzeugt. Dabei kann ein Knoten immer nur mit einem Label markiert sein, daher kann
ein Knoten immer nur Teil einer Bubble sein.

Ziel des Algorithmus ist es diese Bubble so groß wie zu definieren. Als Anfangszustand 
werden alle zu optimierenden Methodenaufrufe mit dem zu verarbeitenden Label markiert.

\subsection{Umsetzung des Algorithmus}

Als Eingabe für den Algorithmus dient ein Objekt vom Typ \texttt{DataFlowGraph}, der 
den bereits beschriebenen Datenflussgraphen darstellt, mit initial markierten
\texttt{Reference}s. Die Implementierung ist in der Klasse \texttt{LabelAnalyzer}
zu finden. 

Ausgehend von den initial markierten Knoten, wir die Definition sowie alle Uses betrachtet,
ob diese für dieses Label

Algorithmus \ref{alg:analyze} beschreibt die Implementierung der Vererbung 
des Labels.

\begin{algorithm}[H]
	\caption{Vererbung des Labels}\label{alg:analyze}
	\begin{algorithmic}[1]
		\STATE $q \gets$ \texttt{new Queue($initialReferences$)}
		\STATE $g \gets$ \texttt{new DataFlowGraph()}
		\WHILE {\texttt{not $q$.isEmpty()}}
			\STATE $r \gets q$\texttt{.remove()}
			\IF {\texttt{not $g$.contains()}}

				\STATE $def \gets$ \texttt{$defUse$.getDef($r$)}
			\ENDIF
		\ENDWHILE
		\RETURN $g$
	\end{algorithmic}
\end{algorithm}

\subsection{Umgang mit mehreren Labels}

\subsection{Umgang mit Phi-Knoten}

$\phi$-Instruktionen innerhalb des Datenflussgraphen erfordern, aufgrund ihrer Eigenheiten,
eine besondere Behandlung.  