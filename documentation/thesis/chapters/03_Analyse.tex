\chapter{Analyse}

Das Folgende Kapitel beschreibt den Analyse Algorithmus, des von mir entworfenen Systems.
Im ersten Abschnitt sollen die verwendeten Datenstrukturen vorgestellt und beschrieben werden.
Der zweite Abschnitt beschreibt den eigentlichen Algorithmus.

\section{Datenstrukturen}

Für den Algorithmus wurden zwei grundlegende Datenstrukturen entworfen. Der 
\textit{Datenflussgraph} repräsentiert den Datenfluss der Referenzen innerhalb 
einer Methode und wird im ersten Abschnitt vorgestellt. Zu optimierende Referenzen
werden in diesem Graphen mit sogenannten \textit{Labels} versehen. Dieser Datentyp
soll im zweiten Abschnitt beschrieben werden.

\subsection{Datenfluss Graph}\label{ssec:DFG}

Eine auf einem IR basierende Methode wird vom System mittels eines Datenflussgraphen 
repräsentiert. Dieser wird vor der eigentlichen Analyse aus einer gegeben
Methode und einer Menge an initialen Referenzen vom \texttt{DataFlowGraphBuilder}
erzeugt. Der Graph ist gerichtet und setzt sich aus zwei verschiedenen Knoten zusammen:

\begin{itemize}
	\item \texttt{Reference}: eine value number aus dem IR
	\item \texttt{InstructionNode}: eine Instruktion aus dem IR
\end{itemize}

Sei im Folgenden der Datenflussgraph $G = (V, E)$, $R$ die Menge aller \texttt{Reference} 
Knoten und $I$ die Menge aller \texttt{InstructionNode}s. 
\\
Im Graph gilt $\forall (x, y) \in V,  (x \in R \wedge y \in I) \vee (x \in I \wedge y \in X)$.
Eine Kante $i \in I, r \in R, (i, r)$ beschreibt eine \textit{Definition}, die aussagt, 
dass die Referenz $r$ durch die Instruktion $i$ definiert wird. Ein Kante 
$i \in I, r \in R, (r, i)$ ist eine \textit{Benutzung} (im folgenden \textit{Use}
genannt). 

\texttt{Reference} Knoten werden für jede betroffene value number erzeugt. Für
die Erstellung von \texttt{InstructionNode} Objekten steht die 
\texttt{InstructionNodeFactory} zur Verfügung, die für eine gegebene 
\texttt{SSAInstruction} eine entsprechende \texttt{InstructionNode} erstellt. Um
für dieselbe \texttt{SSAInstruction} immer dasselbe \texttt{InstructionNode} 
Objekt zu garantieren verwendet die Factory einen internen Cache, der eine 
Abbildung $SSAInstruction \rightarrow InstructionNode$ verwaltet und für jede 
\texttt{SSAInstruction} prüft ob für diese bereits eine \texttt{InstructionNode} 
erstellt wurde.

Die Erstellung eines \texttt{DataFlowGraph}s beginnt immer mit einer Menge an 
initialen \texttt{Reference} Objekten. Ausgehend von dieser Startmenge werden über 
das \texttt{DefUse}-Objekt des betroffenen IRs die Definition und alle Uses in den 
Datenflussgraphen eingefügt. Algorithmus \ref{alg:dfg} beschreibt die Erstellung des 
Graphen. Die verwendete Queue Implementierung ist eine auf einem 
\texttt{java.util.LinkedHashSet} basierende Eigenentwicklung mit dem Namen
\texttt{de.unifrankfurt.faststring.analysis.util.UniqueQueue}.

\begin{algorithm}[H]
	\caption{Erstellung des Datenflussgraphen}\label{alg:dfg}
	\begin{algorithmic}[1]
		\STATE $q \gets$ \texttt{new Queue($initialReferences$)}
		\STATE $g \gets$ \texttt{new DataFlowGraph()}
		\WHILE {\texttt{not $q$.isEmpty()}}
			\STATE $r \gets q$\texttt{.remove()}
			\IF {\texttt{not $g$.contains()}}

				\STATE $def \gets$ \texttt{$defUse$.getDef($r$)}
				\STATE $uses \gets$ \texttt{$defUse$.getUses($r$)}

				\STATE \texttt{$newInd$.add($def$)}
				\STATE \texttt{$newInd$.add($uses$)}

				\STATE \texttt{$r$.setDef(factory.create($def$))}

				\FOR{\texttt{$ins \in defUse$.getUses($r$)}}
					\STATE \texttt{$r$.addUse(factory.create($ins$))}
				\ENDFOR
				\FOR{$ins \in newIns$}
					\STATE \texttt{$q$.add($ins$.getConnectedRefs())}
				\ENDFOR
				\STATE \texttt{$g$.add($r$))}
			\ENDIF
		\ENDWHILE
		\RETURN $g$
	\end{algorithmic}
\end{algorithm}

Jede \texttt{InstructionNode} besitzt eine Definition, die Nummer der Referenz 
die diese Instruktion erzeugt und eine Liste von Uses, die Nummern der Referenzen 
die es benutzt. Darüber hinaus noch Informationen zu Bytecode Spezifika, die 
im Kapitel \ref{sec:locals} betrachtet werden.

Für verschiedene \texttt{SSAInstruction} Typen existieren entsprechende 
\texttt{InstructionNode} Subtypen. Allerdings gibt es auch Typen die nicht
einer \texttt{SSAInstruction} zugeordnet werden können. Im Folgenden sollen die
wichtigsten Knotentypen vorgestellt werden. Es existieren darüber hinaus weitere
für die das System zur Zeit keine Unterstützung bietet, da es ausschließlich für 
String Typen und komplexe Objekte ausgelegt ist.

\subsubsection{MethodCallNode}

Eine \texttt{MethodCallNode} repräsentiert einen Methoden Aufruf. Es besitzt, wenn
vorhanden, eine Definition, welche den Rückgabewert repräsentiert, einen Receiver, 
wenn es keine statische Methode ist und eine Liste an Parametern. Zusätzlich die 
aufgerufene Methode. 

\subsubsection{ContantNode}

Dieser Knoten Typ stellt eine Konstanten Definition dar. Er besitzt ausschließlich 
die Definition, welcher Referenz diese Konstante zugewiesen wird. Für diesen Typ
existiert keine entsprechende \texttt{SSAInstruction}.

\subsubsection{ParameterNode}

Die \texttt{ParameterNode} stellt eine Definition eines Parameters der Methode dar.
Wird eine Variable innerhalb der Methode als Parameter in der Methoden Signatur
deklariert, wird deren Definition als \texttt{ParameterNode} im Datenflussgraphen
repräsentiert. Für diesen Typ existiert keine entsprechende \texttt{SSAInstruction}.

\subsubsection{NewNode}

Dieser Typ entspricht einer \texttt{NEW} Anweisung, die ein neues Objekt eines 
gegebenen Typen erstellt. Es besitzt eine Definition und den Typ des instanziierten
Objekts. 

\subsubsection{ReturnNode}

\texttt{ReturnNode} Typen sind \texttt{RETURN} Anweisungen. Die besitzen 
ausschließlich eine Referenz als Use. Diejenige Referenz, die sie aus der Methode 
zurückgeben. Dieser Typ kann keine Definition darstellen.

\subsubsection{PhiNode}

Die \texttt{PhiNode} steht für eine $\phi$-Instruktion aus dem IR. Sie besitzt eine
Referenz als Definition und 2 bis $n$ Uses.

\subsection{Label}

Das \textit{Label} entspricht einer Markierung, mit der Knoten in einem 
Datenflussgraphen versehen werden können. Dabei steht ein Label (oder 
\texttt{TypeLabel}, wie der Datentyp im System heißt) für einen Optimierten Typ.
Die Semantik hinter einem markierten Knoten ist, dass diese Referenz bzw. Instruktion
durch den entsprechenden Optimierten Typ ersetzt werden kann.

Es kann nicht für alle \texttt{InstructionNode}s ein Label gesetzt werden. Genauer
gesagt lassen sich ausschließlich für die Knotentypen \texttt{MethodCallNode}, 
\texttt{NewNode} und \texttt{PhiNode} ein Label setzen, da sich nur diese 
Instruktionen in einen optimierten Typ umwandeln lassen.

Das \texttt{TypeLabel} beinhaltet alle Regeln, die für die Verwendung eines
Optimierten Typen existieren. Dazu gehören

\begin{itemize}
	\item der Originale, sowie der Optimierte Typ
	\item die Methoden für die Optimierungen im optimierten Typ angeboten werden
	\item alle Methoden die darüber hinaus vom Optimierten Typ unterstützt werden
	\item Methoden, die den optimierten Typ als Rückgabewert zurückgeben
	\item kompatible Label
\end{itemize}

Dabei ist diese Liste bereits eine Abstraktion zu den Methoden, die das Interface 
besitzt. Im System lassen sich Label Definition auf 2 Arten erstellen:

\begin{enumerate} 
	\item Durch das Implementieren des Interfaces \texttt{TypeLabel}
	\item Durch das Erstellen einer \texttt{.type} Datei
\end{enumerate}

Zwar unterstützt das Kommandozeilen Tool zur Zeit nur die zweite Variante,
programmatisch lässt sich allerdings auch die erste Alternative umsetzen. Im 
Folgenden sollen die beiden Möglichkeiten zur Definition eines \texttt{TypeLabel}s
betrachtet werden.

\subsubsection{Das TypeLabel Interface} \label{sssec:typeLabel}

Das Interface beinhaltet alle Methoden, die der Analyse- und Transformationsprozess
benötigt. In diesem Kapitel sollen zunächst nur die Methode betrachtet werden, die
für den Analyse Algorithmus verwendet werden, die Übrigen werden im Abschnitt 
\ref{ssec:infoLabel} betrachtet. 

\begin{description}
	\item[\texttt{canBeUsedAsReceiverFor(MethodReference)}] Legt fest, ob eine 
	markierte Referenz als Empfänger für den übergebenen Methodenaufruf dienen kann.
	\item[\texttt{canBeUsedAsParamFor(MethodReference,int)}] Bestimmt, ob eine 
	markierte Referenz als Parameter in dem gegebenen Methodenaufruf an der 
	entsprechenden Stelle (der \texttt{int} Parameter) verwendet werden kann.
	\item[\texttt{canBeDefinedAsResultOf(MethodReference)}] Sagt aus, ob die 
	gegebene Methode einen optimierten Typ zurückgeben kann. Dies impliziert, dass
	der Methodenaufruf selber auch markiert ist.
	\item[\texttt{findTypeUses(AnalyzedMethod)}] Gibt eine Menge an \texttt{Reference}
	Objekten zurück, auf denen innerhalb der gegebenen Methode eine der von 
	der Optimierung betroffenen Methode aufgerufen wird. Für diesen Algorithmus 
	existiert bereits eine Implementierung in der Klasse \texttt{BaseTypeLabel}.
	\item[\texttt{compatibleWith(TypeLabel)}] Gibt an, ob das übergebene Label 
	kompatibel mit diesem Label ist.
\end{description}

Alle diese Methoden werden von den \texttt{InstructionNode} Implementierungen 
verwendet. Wie genau das passiert wird im Abschnitt \textit{Algorithmus} beschrieben.

\subsubsection{Das .type Dateiformat}

Da das Implementieren des Interfaces eher komplex ist, wurde für die einfachere 
Definition eines Types ein Datei Format entwickelt, welches von der Komplexität des
Interfaces abstrahieren soll. In dieser werden nicht die Regeln selbst, sondern 
die Fakten beschrieben, aus denen die Regeln für den Algorithmus hergeleitet werden 
können, beschrieben.

Aus einer Datei im \texttt{type} Format wird mittels eines internen Parsers ein
\texttt{TypeLabelConfig} Objekt erzeugt, welches als \texttt{TypeLabel} Objekt für
den Algorithmus fungiert.

Für die inhaltliche Struktur der Datei wurde JSON (JavaScript Object Notation) 
gewählt eine Darstellung anzubieten, die sowohl für Menschen als auch für das 
Programm leicht zu lesen und zu verstehen ist. Die Attribute innerhalb der Datei 
werden im Folgenden beschrieben:

\begin{description}
	\item[name] Der Name des Labels
	\item[originalType] Der voll qualifizierte Name des zu ersetzenden Typs
	\item[optimizedType] Der voll qualifizierte Name des zu optimierten Typs
	\item[methodDefs] Liste von Methoden, diesen wird eine ID vergeben um sie im 
	folgenden über diese ID zu referenzieren. Ein Eintrag in dieser Liste setzt
	sich zusammen aus:
	\begin{description}
		\item[id] eine eindeutige ID für die diese Methode
		\item[desc] die Beschreibung dieser Methode. Dies ist ein eigenes Objekt 
		und besteht aus den Attributen:
		\begin{description}
			\item[name] der Name der Methode
			\item[signature] der Signatur der Methode. Zusammengesetzt aus der
			Parameterliste und der Rückgabewert. Die Typen müssen dabei in der 
			internen JVM Form angegeben werden. (Beispiel: "\texttt{(I)Ljava/lang/String;}"
			, ein Parameter vom Typ \texttt{int} und Rückgabewert vom Typ
			\texttt{java.lang.String})
		\end{description}	
	\end{description}
	\item[effectedMethods] Liste von Methoden IDs. Für diese Methoden existieren 
	optimierte Varianten in dem optimierten Typen.
	\item[supportedMethods] Liste von Methoden IDs. Diese Methoden werden auch vom
	optimierten Typ unterstützt. Es handelt sich bei diesen aber nicht um Optimierungen.
	\item[producingMethods] Liste von Methoden IDs. Alle diesen Methoden erzeugen 
	in ihrer optimierten Variante optimierte Typen.
	\item[compatibleLabel] Liste von Strings. Alle Labels die mit diesem Label
	kompatibel sind.
	\item[parameterUsage] Ein Objekt. Dabei ist jeder key die ID einer Methode 
	und der entsprechende value eine Liste von Ganzzahlen. Ein Eintrag bedeutet, 
	dass diese Methode mit einem Optimierten Typ als Parameter mit diesem Index 
	umgehen kann. 
	\item[optimizedParams] Ein Objekt. Dabei ist jeder key die ID einer Methode 
	und der entsprechende value eine Parameter Liste in interner JVM Notation. 
	Wird bei einer Optimierung einer Methode eine andere Parameter Liste erwartet
	als die ursprüngliche der originalen Methode, so muss die neue Signatur an dieser
	Stelle angegeben werden.
	\item[staticFactory] Ein String. Der Name einer statischen Factory Methode mit 
	einem Übergabeparameter vom Typ des Originalen Typs. Diese muss einen entsprechenden
	Optimierten Typ zurückgeben.
	\item[toOriginalType] Ein String, Der Name einer Methode ohne Parameter, die
	aus dem optimierten Objekt, ein entsprechendes vom Originalen Typ zurückgibt.

\end{description}

\subsection{Konventionen}\label{subs:conventions}

Bei dem Erstellen von optimierten Typen sind einige Konventionen zu befolgen. Das 
System rechnet damit, dass diese Annahmen befolgt werden. Diese Regeln sind im Folgenden
beschrieben.

\subsubsection{Methodennamen}

Wird eine Methode als \textit{effectedMethod} deklariert, wird der optimierte Gegensatz
durch den Namen identifiziert. Wenn z.B. die Methode \texttt{f()} aus dem Typ \texttt{A}
optimiert werden soll, so muss in dem optimierten Typ \texttt{AOpt} eine Methode
\texttt{f()} existieren. Besitzt die originale Methode eine Parameterliste, so muss
diese mit derer der optimierten Methode in Anzahl und Typen übereinstimmen. Eine Ausnahme
bildet dabei die Verwendung von ebenfalls optimierten Parametern. In diesem Fall muss im Feld 
\textit{optimizedParams} in der \textit{type} Datei ein entsprechender Eintrag erfolgen.


\section{Algorithmus}

In diesem Abschnitt soll die Idee hinter dem Analyse Algorithmus sowie dessen
Implementierung vorgestellt werden. Hierzu wird zunächst das Konzept der "Bubble"
erläutert um danach die Umsetzung dieses Konzepts im eigentlich Algorithmus zu 
betrachten.

\subsection{Motivation}

Optimierte Referenzen sind im Falle von String Objekten nicht kompatibel mit den 
Originalen. So treten Probleme in den Folgenden Szenarien auf:

\begin{description}
	\item[Referenz als Methoden Parameter] Die Signatur der 
	optimierten Methode, wird nicht verändert, da es dazu führen würde, dass
	Klienten Code, der diese Methode weiterhin mit dem originalen Typ aufruft, 
	nicht mehr kompilieren würde.
	\item[Referenz als Rückgabewert] Ein ähnliches Problem existiert, wenn die 
	Referenz zurückgegeben wird. Die Signatur der Methode definiert den Originalen
	Typ als Rückgabetyp und das zurückgeben eines anderen Typs als eben dieser 
	definierte würde zu Laufzeitfehlern führen.
	\item[Methodenaufruf auf Referenz] Wird diese optimierte Referenz als Empfänger 
	von einer Methode verwendet, die nicht zu den optimierten oder unterstützen
	Methoden dieses optimierten Typs gehört, würde es zu Laufzeitfehlern kommen, 
	da diese aufzurufende Methode nicht im optimierten Typ vorhanden ist. 
	\item[Feld Zugriff (\texttt{GETFIELD}, \texttt{PUTFIELD})] Wird die optimierte 
	Referenz in ein oder aus einem Feld innerhalb eines Objektes (oder in ein 
	statisches Feld einer Klasse) gesetzt, stimmt auch in diesem Szenario der Typ
	des optimierten und des originalen Objekts nicht überein.
	\item[Array Zugriff] Bei dem Zugriff auf ein Array, sowohl lesend als auch 
	schreibend, existiert eine Unstimmigkeit mit dem Typ des Arrays.
	\item[Referenz Aufruf Parameter] Wird die Referenz als Parameter für einen
	Methoden Aufruf verwendet und diese Methode ist nicht in der Label Definition
	als Methode deklariert, die mit einem optimierten Typ umgehen kann, dann 
	erwartet diese Methode den originalen Typ und nicht den optimierten.
\end{description}

Erweitert allerdings der optimierte Typ seinen originalen Typ so wäre, durch den 
Polymorphismus, der optimierte Typ genauso wie der originale verwendbar. Allerdings 
ist der Typ \texttt{java.lang.String} final, was bedeutet, dass von diesem Typ nicht 
abgeleitet werden kann. Darüber hinaus bieten sich Ableitungen für Optimierungen nicht
an, da das dynamische dispatchen zusätzlichen Aufwand für die JVM darstellt, da 
zunächst die Implementierung des Methode zu lokalisieren.

Aus diesem Grund müssen in den Code Konvertierungen in und vom optimierten Typ 
eingefügt werden. Eine Konvertierung zum optimierten Typ muss vor dem zu optimierenden
Methodenaufruf erfolgen. Eine Umwandlung vom optimierten Typ allerdings muss vor einer 
nicht kompatiblen Benutzung dieser Referenz erfolgen um bei dieser den originalen Typ 
zu verwenden.

\subsection{Die "Bubble"}

Da Konvertierungen zusätzliche Laufzeit erfordern, muss es das Ziel sein die Anzahl 
der durchgeführten Konvertierungen zu minimieren. Dies wird erreicht indem man den
Bereich, in dem ein optimierter Typ statt des originalen innerhalb der Methode 
verwendet maximiert. Dieser Bereich, in dem ein optimierter, statt des originalen, 
Typs für eine Referenz verwendet wird, wird im Folgenden \textit{Bubble} genannt. 

Die Bubble entsteht mittels der Markierung von Knoten im Datenflussgraphen. Es wird 
für jede gegebene Instanz vom Typ \texttt{TypeLabel} eine Bubble auf dem Graphen 
erzeugt. Dabei kann ein Knoten immer nur mit einem Label markiert sein, daher kann
ein Knoten immer nur Teil einer Bubble sein.

Ziel des Algorithmus ist es diese Bubble so groß wie zu definieren. Als Anfangszustand 
werden alle zu optimierenden Methodenaufrufe mit dem zu verarbeitenden Label markiert.

\subsection{Umsetzung des Algorithmus}\label{ssec:umAlg}

Als Eingabe für den Algorithmus dient ein Objekt vom Typ \texttt{DataFlowGraph}, der 
den bereits beschriebenen Datenflussgraphen darstellt. Zum Erstellen des Graphen werden
wie in \ref{ssec:DFG} beschrieben zunächst initiale Referenzen benötigt. Diese Referenzen
werden über die Methode \texttt{Set<Reference>} \\ \texttt{findTypeUses(AnalyzedMethod)} ermittelt, 
welche sich in der abstrakten Klasse \texttt{BaseTypeLabel} befindet. Diese Methode ist auch Teil des 
\texttt{TypeLabel} Interfaces. Grundlage dieser Ermittlung sind die von der in der Label 
Definition definierten \textit{effectedMethods}, also derjenigen Methoden für die dieses 
Label eine Optimierung darstellt. Die \texttt{findTypeUses} Methode erstellt für jede 
Referenz, auf der in der gegebenen Methode eine der \textit{effectedMethods} aufgerufen 
wird, ein \texttt{Reference} Objekt. Dabei wird für jede value number genau ein Referenz 
Objekt erzeugt. Die erstellten Referenzen werden dem verwendeten Label markiert.

Die Implementierung des Algorithmus befindet sich als statische Methode in der Klasse 
\texttt{LabelAnalyzer}. Ausgehend von den initial markierten Knoten, wird jeweils die 
Definition sowie alle Uses einer Referenz betrachtet, ob diese mit dem Label der Referenz 
markiert werden können. Der Algorithmus \ref{alg:analyze} beschreibt die Implementierung 
dieser Vererbung des Labels. Als Queue findet wieder die 
\texttt{de.unifrankfurt.faststring.analysis.util.UniqueQueue} Verwendung.

\begin{algorithm}[H]
	\caption{Vererbung des Labels}\label{alg:analyze}
	\begin{algorithmic}[1]
		\STATE $q \gets$ \texttt{new Queue($initialReferences$)}
		\STATE $g \gets$ der übergebene Datenflussgraph
		\WHILE {\texttt{not $q$.isEmpty()}}
			\STATE $r \gets q$\texttt{.remove()}
			\IF {\texttt{$r$.label} is not \texttt{null}}
				\STATE $def \gets$ \texttt{$r$.getDef()}
				\IF {\texttt{$def$.canProduce($r$.label)}}
					\STATE \texttt{labelConnectedRefs($def$)}
				\ENDIF
				\FOR {$use$ \bf{in} \texttt{$r$.getUses()}}
					\IF {\texttt{$use$.canUseAt($r$.label, $useIndex$)}}
						\STATE \texttt{labelConnectedRefs($use$)}
					\ENDIF
				\ENDFOR
			\ENDIF
		\ENDWHILE
		\RETURN $g$
	\end{algorithmic}
\end{algorithm}

Eine wichtige Rolle während des Vererbungsprozesses spielen dabei die Methoden 
\texttt{boolean Labelable.canProduce(TypeLabel)} und \\
\texttt{boolean Labelable.canUseAt(TypeLabel, int)}. Diese beiden Methoden bestimmen 
für eine Referenz ob ein Label auf eine Definition oder eine Benutzung vererbt werden kann.

\texttt{canProduce} sagt aus ob eine Instruktion eine optimierte Referenz definieren kann. 
Die Implementierungen der \texttt{canProduce} Methode sehen für die einzelnen \texttt{Labelable}
Subtypen wie folgt aus:

\begin{description}
	\item[NewNode] gibt immer \texttt{true} zurück
	\item[ConditionalBranchNode] gibt immer \texttt{false} zurück
	\item[MethodCallNode] Delegation an die Methode \texttt{canBeDefinedAsResultOf} des 
	übergebenen Label Objekts.
\end{description}

Die Methode \texttt{canUseAt} betrifft dagegen nur Benutzungen von Referenzen. Die Semantik
hinter der Methode ist ob diese Instruktion eine optimierte Referenz verwenden kann. Der Index 
stellt dabei den Parameter Index das an dem diese Referenz in dieser Instruktion verwendet wird. 
Die Implementierung dieser Methode sieht für die einzelnen \texttt{Labelable}
Subtypen wie folgt aus:

\begin{description}
	\item[NewNode] gibt immer \texttt{false} zurück
	\item[ConditionalBranchNode] gibt immer \texttt{true} zurück
	\item[MethodCallNode] Wenn die Methode nicht statisch und der Index 0 ist, wird an die Methode
	\texttt{canBeUsedAsReceiverFor} delegiert, andernfalls an die Methode \texttt{canBeUsedAsParamFor}.
\end{description}

Ist für eine Instruktion die Prüfung für die entsprechende Methode positiv, wird diese 
Instruktion an die Hilfsfunktion \texttt{labelConnectedRefs} weitergeleitet. Diese Methode 
ist im folgenden dargestellt:

\begin{algorithm}[H]
	\caption{labelConnectedRefs}\label{alg:labelConnRefs}
	\begin{algorithmic}[1]
		\STATE \texttt{$node$.setLabel($label$)}
		\FOR{$ref$ \bf{in} $node$\texttt{.getLabelableRefs()}}
			\IF{\texttt{$ref$.getLabel()} is not \texttt{null}}
				\STATE \texttt{$ref$.setLabel($label$)}
				\STATE \texttt{$q$.add($ref$)}
			\ENDIF 
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

Wobei sowohl die Queue $q$, als auch das betreffende TypeLabel $label$ aus dem umgebenen Kontext
im Algorithmus \ref{alg:analyze} auch in dieser Funktion zur Verfügung stehen. 

\subsection{Umgang mit mehreren Labels}

Es ist möglich für die Analyse mehrere Labels für die Analyse zu verwenden. Diese lassen
sich dem \texttt{MethodAnalyzer} als \texttt{Collection} im Konstruktor zusammen 
mit der zu analysierenden Methode übergeben. Vor der Analyse werden zuerst alle Referenzen 
identifiziert von denen eine zu optimierende Methode verwendet wird. Diese Referenzen werden 
zu einer Menge an Referenzen vereint. Die auf diese Weise erzeugten Referenzen besitzen 
wie in \ref{ssec:umAlg} beschrieben jeweils das Label für das die Referenz erzeugt wurde.

Ein Problem ergibt sich, stellt man der Analyse mehrere Labels zur Verfügung, die allerdings
Optimierungen für dieselbe Methode des selben Typs beschreiben. Die erzeugten initial erzeugten 
Referenz-Objekte, welche die zu optimierende Methode verwenden, werden bei ihrer Erzeugung
mit dem entsprechenden Label markiert. Dieses Implementierungsdetail führt dazu, dass 
die entsprechenden Referenzen mit demjenigen Label markiert werden, welches zuerst verarbeitet wird.
Dieses wird immer das Label sein, welches einen geringeren Index in der Liste von Labels 
besitzt. 

Stellt man der Methode nun zwei unterschiedliche Labels zur Verfügung, die allerdings den
selben originalen Typen verwenden, ergibt sich ein anderes Problem, wenn innerhalb der analysierten 
Methode auf einer Referenz sowohl die eine als auch die andere Methode aufgerufen wird. Da das 
System jeder Referenz in einer Methode nur ein Label zuweisen kann, kann diese Referenz, welche 
beide Methoden der beiden TypeLabels verwendet, nur mit einem der TypeLabels markiert werden. 
In diesem Szenario wird wieder dasjenige Label für die Markierung verwendet, welches den niedrigeren
Index innerhalb der Liste besitzt.

Nachdem der Datenflussgraph initial erzeugt wurde, wird der Algorithmus wie in \ref{ssec:umAlg} 
beschrieben ausgeführt. Da Labels nur auf Knoten vererbt werden, gilt dass der entsprechende
Knoten dasjenige Label erhält, welches zuerst auf diesen Knoten vererbt wird.  

\subsection{Phi-Knoten}

$\phi$-Instruktionen innerhalb des Datenflussgraphen erfordern, aufgrund ihrer Eigenheiten,
eine besondere Behandlung. Da sie keine Instruktionen im eigentlichen Sinne darstellen, sondern
nur ein Zeiger alias für andere Referenzen darstellen, lassen sich diese Knoten auch nicht
optimieren. Obwohl sie selber nicht optimiert werden können, so lässt sich doch über diese 
Knoten hinweg ein Label vererben. Allerdings sollte unterschieden werden zwischen denjenigen
verbundenen Referenzen, für die eine Markierung tatsächlich sinnvoll und für welche eher
weniger sinnvoll ist. 

Daher sollten diejenigen Referenzen markiert werden, für die auch Optimierungspotenzial 
besteht. Wohingegen diejenigen Referenzen, für die keinerlei Optimierung notwendig 
ist, auch keine Markierung erhalten sollten. 

Wenn das System beim Vererben der Markierung einen $\phi$-Knoten als Instruktion verarbeitet,
wird dieser auf den $\phi$ Stapel gelegt und alle verbundenen Referenzen für die
weitere Verarbeitung vorgemerkt. Nachdem alle Referenzen verarbeitet wurden, wird dieser
Stapel durchlaufen. Für jede \texttt{PhiInstructionNode} in diesem Stapel wird entschieden
ob und mit welchem Label diese Instruktion markiert wird. 