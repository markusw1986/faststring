\chapter{Werkzeuge}

In den folgenden Abschnitten sollen die verwendeten Werkzeuge kurz vorgestellt werden. Dabei handelt es 
sich sowohl um den Java Bytecode, als auch um die Software Bibliothek \textit{WALA}, auf deren API das 
in dieser Arbeit entwickelte System basiert. 

\section{Java Bytecode}

Die Plattformunabhängigkeit, die in Java geschriebenen Programmen zugesprochen wird, 
ist vor allem mit der Rolle der Java Virtual Machine zu erklären. Java Programme werden 
in einen Zwischencode, den Java Bytecode, übersetzt, welcher von der System spezifischen 
JVM ausgeführt wird. Dabei ist Programmiersprache Java nicht die einzige in Bytecode 
übersetzbare Sprache. Es existieren neben den bekanntesten Scala, Jython, Groovy,
JavaScript noch viele weitere. Einmal in Bytecode übersetzt können, in diesen Sprachen 
geschriebene, Programme auf jeder, der Java Spezifikation entsprechenden, JVM ausgeführt 
werden. 

Bytecode ist eine Sammlung von Instruktionen welche durch \textit{opcodes} von 2 Byte Länge definiert 
werden. Zusätzlich können noch 1 bis $n$ Parameter verwendet werden. Die Sprache ist Stack-orientiert, das 
bedeutet, dass von Operationen verwendete Parameter über einen internen Stack übergeben werden. Als Beispiel 
dient der folgende Bytecode:

\begin{figure}[H]
	\begin{lstlisting}[language=Bytecode]
		ICONST 5 	// legt den konstanten int Wert 5 auf den Stack 
		ILOAD 1		// läd die lokale integer Variable 1 und legt sie auf den Stack
		IADD 		// addiert die ersten beiden Werte auf dem Stack und legt das Ergebnis auf den Stack
		ISTORE 2	// speichert den Wert auf dem Stack in der Variable 2
	\end{lstlisting} 
	\caption{Java Bytecode Beispiel}
\end{figure}

Dabei existiert der Stack nur als Abstraktion für den eigentlichen Prozessor im Zielsystem. Wie die 
jeweilige JVM den Stack in der Ziel Plattform umsetzt ist nicht definiert. Die Instruktionen lassen sich in 
folgende Kategorien einordnen:

\begin{itemize}
	\item Laden und Speichern von lokalen Variablen (\texttt{ILOAD}, \texttt{ISTORE})
	\item Arithmetische und logische ausdrücke (\texttt{IADD})
	\item Object Erzeugung bzw. Manipulation (\texttt{NEW}, \texttt{PUTFIELD})
	\item Stack Verwaltung (\texttt{POP}, \texttt{PUSH}) 
	\item Kontrollstruktur (\texttt{IFEQ}, \texttt{GOTO})
	\item Methoden Aufrufe (\texttt{INVOKEVIRTUAL}, \texttt{INVOKESTATIC})
\end{itemize}  


\section{WALA}

Bei \textit{WALA} handelt es sich um die "T.J. Watson Library for Analysis". Eine ehemals von IBM 
entwickelte Bibliothek für die statische Codeanalyse von Java- und JavaScript Programmen. Das Framework 
übernimmt dabei das Einlesen von \textit{class} Dateien und stellt eine Repräsentation, die sogenannte 
\textit{Intermediate Representation}, des Bytecodes zur Verfügung. Diese IR stellt die zentrale 
Datenstruktur dar und soll in diesem Abschnitt detailliert beschrieben werden.

Für die Manipulation des Bytecodes existiert innerhalb des Frameworks ein Unterprojekt, das diese Aufgabe 
übernimmt: Shrike. Im Zweiten Abschnitt soll diese API kurz vorgestellt werden.  

\subsection{IR}

Die \textit{Intermediate Representation} (IR) ist eine Abstraktion zum Stack basierten Bytecode. Ein IR ist
in Single Static Assignment Form, welche sich dadurch auszeichnet, dass jeder Variablen immer genau 
\textbf{einmal} ein Wert zugewiesen wird. Zusätzlich besteht die IR aus dem Kontrollflussgraphen der 
Methode, welcher wiederum aus Basic Blocks zusammengesetzt ist. Ein Basic Block ist eine Zusammenfassung 
von aufeinander Folgende Instruktionen, welche in jedem Fall nach einander ausgeführt werden.

Die Variablen innerhalb des IRs nennt WALA \textit{value numbers}. Diese beziehen sich immer auf eine 
Referenz, allerdings kann sich eine Referenz sich auf mehrere tatsächliche value numbers in der IR beziehen.
Dies folgt aus der SSA Form, wird eine Variable im Bytecode zweimal ein Wert zugewiesen, wird diese 
doppelte Zuweisung in der SSA Form durch das Einführen einer neuen value number entfernt. Die Operationen
werden auch nur mit Bezug auf die value numbers beschrieben.   
 
Da die Zwischendarstellung vom Stack abstrahieren soll, werden auch alle Operationen, die den Stack betreffen
(wie z.B. \texttt{LOAD}, \texttt{STORE}, \texttt{PUSH} oder \texttt{POP}) nicht nicht mit in diese 
Repräsentation übernommen. Dabei werden die Bytecode Indices der übrig gebliebenen Instruktionen 
berücksichtigt und alle anderen Stellen in dem beinhaltenden Array mit \texttt{null} Werten aufgefüllt.
Instruktionen werden von Objekten vom Typ \texttt{SSAInstruction} und dessen Untertypen dargestellt.

Die Verwaltung der value numbers wird von einem Typ namens \texttt{SymbolTable} übernommen. Es kommt bei der
IR Erstellung zum Einsatz, wenn bei der Simulation des Bytecodes neue Variablen verwendet werden, um neue 
value numbers zu erzeugen.

Aufgrund der SSA Form der IR lässt sich für jede value number genau eine Definition bestimmen. Zu diesem 
Zweck bietet WALA den Typ \texttt{DefUse} an, welcher für jedes IR-Objekt erstellt werden kann. Er ermöglicht
einen einfachen Zugriff aus die Instruktionen, die eine value number definiert (\textit{def}; z.B. als 
Rückgabe aus einem Methodenaufruf), und eine Menge an Instruktionen, die die entsprechende value number 
verwenden (\textit{use}; z.B. als Rückgabewert in einem \texttt{RETURN} Statement).

Besitzt ein Block im Kontrollflussgraphen mehrere eingehende Kanten und werden aus diesen Vorgänger Blöcken
Variablen mitgebracht die synonym in diesem Block verwendet werden, werden in SSA-Form sogenannte $\phi$ 
Funktionen verwendet. Eine Instruktion der Form $v_3 = \phi(v_1, v_2)$ sagt aus, dass im Folgenden 
die Referenz $v_3$ sowohl $v_1$, als auch $v_2$ sein kann. Da die statische Code Analyse nicht feststellen
kann von welchem Block aus dieser Block betreten wurde, werden diese $\phi$-Funktionen verwendet, um
die Zusammenführungen von mehreren Variablen aus Vorgängerblöcken darzustellen.

Das IR und das dazugehörige DefUse Objekt werden in dem System internen Datentyp \texttt{AnalyzedMethod} 
zusammengefasst.

\subsubsection{Anpassungen}

In WALA werden beim Erstellen des IR für alle Konstanten mit demselben Wert dieselbe value numbers erzeugt. 
Da für die \textit{Analyse} verschiedenen Referenzen getrennt getrennt untersucht werden mussten, wurde 
für die Erzeugung einer value number für eine Konstante der eingebaute caching Mechanismus umgangen. 

Darüber hinaus war für die \textit{Transformation} die Information nötig, an welcher Stelle im Bytecode eine
entsprechende Konstante erzeugt wird (z.B. mittels \texttt{LCD}). Um dies zu Erreichen wurde dieser Bytecode 
Index während dem Durchlaufen der Instruktionen innerhalb der \texttt{SymbolTable} gespeichert, sodass er 
beim Klienten des IRs zur Verfügung steht.

Da diese Änderungen nicht in den Haupt Branch von WALA eingepflegt werden durften, benötigt das System den 
Fork des WALA Projektes \footnote{Dieser ist unter \texttt{http://github.com/wondee/WALA} zu finden.}.


\subsection{Shrike}

Shrike ist ein Unterprojekt innerhalb des WALA Frameworks. Shrike übernimmt dabei das Lesen und das 
Schreiben von Bytecode aus bzw. in class Dateien. Dabei wird es zum einen beim Erstellen eines IR aus einer 
Methode verwendet, zum Anderen bietet es eine "Patch-based" API an um den Bytecode einer eingelesenen 
Methode zu verändern. Dies geschieht über das Einfügen von \texttt{Patch}es, welche über einen 
entsprechenden \texttt{MethodEditor} überall im Bytecode einer Methode eingefügt werden oder auch 
ursprüngliche Instruktionen komplett ersetzen. Zusätzlich enthält es einen \texttt{Verifier}, der erzeugten 
Bytecode überprüft, so dass ungültige Stack Zustände oder Typfehler noch während der Manipulation erkannt 
werden können. 

In dem von mir entwickelten System werden alle Bytecode Manipulationen mit Hilfe von Shrike umgesetzt. 

\chapter{Optimierte Stringtypen}\label{stringLabels}

Im Rahmen dieser Arbeit wurden zwei alternative String Typen die Optimierungen der ursprünglichen
\texttt{java.lang.String} API darstellen. Diese Typen umgehen das Design der String Repräsentationen
in Java, die \textit{nicht veränderbare} Objekte darstellen. Durch diesen Umstand führen alle
Manipulationsoperationen auf String Typen dazu, dass die Daten auf denen diese Objekte basieren
(ein \texttt{char} Array, dass die einzelnen Zeichen der Zeichenkette hält) kopiert werden müssen.
Es sind über die hier vorgestellten Typen durchaus weitere Optimierungen für den String Typ denkbar, 
doch wurden im Rahmen dieser Arbeit nur diese beiden Typen betrachtet. Diese Typen befinden sich
im Maven Artefakt \textit{faststring-core}.

\section{SubstringString} 

Der Typ \texttt{de.unifrankfurt.faststring.core.SubstringString} dient als Optimierung für
die Methode \texttt{java.lang.String.substring(..)}. Dabei dient das \texttt{char} Array als
Daten für die repräsentierte Zeichenkette. 

\section{StringListBuilder} 